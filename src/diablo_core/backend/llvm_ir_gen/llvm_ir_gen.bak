open Llvm
open Ast.Ast_types
open Lowering

module Codegen = struct
  exception LLVMError of string

  let context = global_context ()
  let diablo_module = create_module context "DiabloModule"
  let builder = builder context
  let named_values : (string, llvalue) Hashtbl.t = Hashtbl.create 10
  let i32_t = i32_type context
  let i1_t = i1_type context
  let i8_t = i8_type context

  let llvm_type = function
    | TConst "int" -> i32_t
    | TConst "bool" -> i1_t
    | TConst "str" -> pointer_type context
    | TConst "unit" -> void_type context
    | TArrow _ -> i32_t
    | ty -> raise (LLVMError ("Unsupported type" ^ string_of_ty ty))

  let declare_extern_function name return_type param_types diablo_module =
    declare_function name
      (function_type (llvm_type return_type)
         (Array.of_list (List.map llvm_type param_types)))
      diablo_module

  let rec codegen_expr = function
    | Lowered_ast.Integer n -> const_int i32_t n
    | Lowered_ast.Boolean b -> const_int i1_t (if b then 1 else 0)
    | Lowered_ast.StringLiteral s -> build_global_stringptr s "str" builder
    | Lowered_ast.Identifier (name, ty) -> (
        try match ty with
        | TConst "int" | TConst "bool" | TConst "str" | TConst "unit" ->
            print_endline ("load" ^ name ^ string_of_ty ty ^ "\n");
            build_load (llvm_type ty)
              (Hashtbl.find named_values name)
              name builder
        | TArrow _ ->
            Printf.printf "funcccc %s\n" name;
            Hashtbl.find named_values name
        | _ ->
            raise (LLVMError ("Unsupported type" ^ string_of_ty ty));
        with Not_found -> raise (LLVMError ("Unknown variable " ^ name)))
    | Lowered_ast.BinOp (op, lhs, rhs, _ty) -> (
        let lhs_val = codegen_expr lhs in
        let rhs_val = codegen_expr rhs in
        match op with
        | BinOpPlus -> build_add lhs_val rhs_val "addtmp" builder
        | BinOpMinus -> build_sub lhs_val rhs_val "subtmp" builder
        | BinOpMult -> build_mul lhs_val rhs_val "multmp" builder
        | BinOpDiv -> build_sdiv lhs_val rhs_val "divtmp" builder
        | BinOpRem -> build_srem lhs_val rhs_val "modtmp" builder
        | BinOpLessThan -> build_icmp Icmp.Slt lhs_val rhs_val "lttmp" builder
        | BinOpGreaterThan ->
            build_icmp Icmp.Sgt lhs_val rhs_val "gttmp" builder
        | BinOpLessThanEqual ->
            build_icmp Icmp.Sle lhs_val rhs_val "letmp" builder
        | BinOpGreaterThanEqual ->
            build_icmp Icmp.Sge lhs_val rhs_val "getmp" builder
        | BinOpAnd -> build_and lhs_val rhs_val "andtmp" builder
        | BinOpOr -> build_or lhs_val rhs_val "ortmp" builder
        | BinOpEqual -> build_icmp Icmp.Eq lhs_val rhs_val "eqtmp" builder
        | BinOpNotEqual -> build_icmp Icmp.Ne lhs_val rhs_val "netmp" builder)
    | Lowered_ast.UnOp (op, expr, _ty) -> (
        let expr_val = codegen_expr expr in
        match op with
        | UnOpNegate -> build_neg expr_val "negtmp" builder
        | UnOpNot -> build_not expr_val "nottmp" builder)
    | Lowered_ast.Call (callee, args, ret_type) ->
        (* TODO: The callee can be any expression (like an identifier, a lambda function, or even a complex expression that evaluates to a function) *)
        let callee =
          match callee with
          | Lowered_ast.Identifier (name, _) -> name
          | _ -> raise (LLVMError "[Call] Unsupported type")
        in
        let callee =
          match lookup_function callee diablo_module with
          | Some callee -> callee
          | None -> raise (LLVMError ("Unknown function referenced: " ^ callee))
        in
        (* Printf.printf "Callee\n";
        let callee = codegen_expr callee in
        (* If the callee is an identifier or something more complex, it should resolve to a function pointer *)
        let callee =
          build_load (pointer_type context) callee "calltmp" builder
        in *)
        let params = params callee in
        if Array.length params == List.length args then ()
        else
          raise
            (LLVMError
               ("Expected "
               ^ string_of_int (Array.length params)
               ^ " arguments, got "
               ^ string_of_int (List.length args)));
        let arr_args = Array.of_list (List.map codegen_expr args) in
        let ret_type = llvm_type ret_type in
        let arg_types =
          Array.of_list
            (List.map
               (fun arg ->
                 match arg with
                 | Lowered_ast.Integer _ -> llvm_type (TConst "int")
                 | Lowered_ast.Boolean _ -> llvm_type (TConst "bool")
                 | Lowered_ast.StringLiteral _ -> llvm_type (TConst "str")
                 | _ -> raise (LLVMError "[Call] Unsupported type for argument"))
               args)
        in
        let fnty = function_type ret_type arg_types in

        build_call fnty callee arr_args "calltmp" builder
    | Lowered_ast.Let (name, value_expr, body_expr, ty) ->
        let expr_val = codegen_expr value_expr in
        let the_function = block_parent (insertion_block builder) in
        let entry_block = entry_block the_function in
        let entry_builder = builder_at context (instr_begin entry_block) in

        let alloca = build_alloca (llvm_type ty) name entry_builder in
        let _ = build_store expr_val alloca entry_builder in

        let old_binding =
          if Hashtbl.mem named_values name then
            Some (Hashtbl.find named_values name)
          else None
        in
        Hashtbl.replace named_values name alloca;

        let body_val = codegen_expr body_expr in

        (match old_binding with
        | Some v -> Hashtbl.replace named_values name v
        | None -> Hashtbl.remove named_values name);

        body_val
    | Lowered_ast.Function (name, params, body, return_type) -> (
        Hashtbl.clear named_values;

        let param_types = List.map (fun (_, ty) -> llvm_type ty) params in
        let func_type =
          function_type (llvm_type return_type) (Array.of_list param_types)
        in

        let the_function =
          Printf.printf "Function: %s\n" name;
          match lookup_function name diablo_module with
          | None -> declare_function name func_type diablo_module
          | Some f ->
              if block_begin f <> At_end f then
                raise (LLVMError "Function already defined");
              if element_type (type_of f) <> func_type then
                raise (LLVMError "Function already defined with different type");
              f
        in

        List.iteri
          (fun i (pname, _) ->
            let param = param the_function i in
            set_value_name pname param;
            Hashtbl.add named_values pname param)
          params;

        (* ?: Should this be moved into codegen_block *)
        (* The problem is that "the_function" used in the line below is specific to the current function *)
        let bb = append_block context "entry" the_function in
        position_at_end bb builder;

        try
          let ret_val = codegen_expr body in
          let _ = build_ret ret_val builder in
          Llvm_analysis.assert_valid_function the_function;
          the_function
        with e ->
          delete_function the_function;
          raise (LLVMError (Printexc.to_string e)))
    | _ -> raise (LLVMError "Unknown expression")

  let codegen_main (body : Lowered_ast.expr) =
    let main_type =
      function_type (llvm_type (TConst "int"))
        (Array.make 0 (llvm_type (TConst "int")))
    in
    let main_func = declare_function "main" main_type diablo_module in

    let bb = append_block context "entry" main_func in
    position_at_end bb builder;

    try
      let ret_val = codegen_expr body in

      let _ = build_ret ret_val builder in

      Llvm_analysis.assert_valid_function main_func;

      main_func
    with e ->
      delete_function main_func;
      raise (LLVMError (Printexc.to_string e))

  let declare_extern_functions () =
    Hashtbl.add named_values "ext_add"
      (declare_extern_function "ext_add" (TConst "int")
         [ TConst "int"; TConst "int" ]
         diablo_module);
    let printf_ty =
      var_arg_function_type i32_t [| pointer_type (type_context i8_t) |]
    in
    let printf = declare_function "printf" printf_ty diablo_module in
    Hashtbl.add named_values "printf" printf

  let codegen_program = function
    | Lowered_ast.Program (_import_stms, funcs, main_block, _) ->
        Printf.printf "Compiling %d functions\n" (List.length funcs);
        declare_extern_functions ();

        List.iter (fun func -> ignore (codegen_expr func)) funcs;
        ignore (codegen_main main_block)

  let print_module_to_stderr () = dump_module diablo_module
  let save_module_to_file filename = print_module filename diablo_module
end
